# Haskell入門

## はじめに
### 環境構築
- [GHCup](https://www.haskell.org/ghcup/)を使えばぜんぶやってくれる
- インストールされるもの
  - GHCup（Haskellのツールチェーンを管理するやつ）
  - GHC（コンパイラ）
  - cabal（パッケージマネージャ）
  - stack（cabalのラッパー）
  - hls（エディタの補完をしてくれるやつ）

### ghci（デバッグに便利な対話環境）の使い方
- ターミナルで `ghci` というコマンドを打つと対話環境が起動する
- `100 + 200` とか、`2 ** 10` とか、適当に数式を打ってみよう！評価してくれるぞ！
- `someconst = 3` みたいに定数を定義すると、あとで使うことができる
- 関数はふつうの値なので、`nibai = \x -> x * 2` みたいに打てば定義できる（ここで、`\x -> x * 2` は「引数xを受け取ってx * 2を返す関数」という意味）
- 関数を使うには、関数のあとにスペースを空けて引数を書けばいい。`nibai 3` と打つと、`6`が帰ってくる
- 関数を定義したかったら `sanbai x = x * 3` のように書くこともできる
- ghciは`:q` で終了できる

- どこか適当なフォルダに、`hoge.hs` というファイルを作って、以下のように書いてみる
- （この先しばらく、VSCodeで`hoge.hs`とターミナルを開きながら作業する）
```haskell
-- ↓コメント
-- Haskellのプログラムは基本的に、定数の宣言でできている
someconst = 3

nibai = \x -> x * 2

sanbai x = x * 3
```
- ghciを起動して、`:l hoge.hs` と打つと、`hoge.hs` の宣言が読み込まれる
- 当然 `someconst` と打てば `3` が返ってくるし、`nibai someconst` と打てば `6` が返ってくる

#### 節末問題
- ここまでの知識だけで、「二個の引数を取る関数」は作れるだろうか？
  - たとえば、`(kakezan 3) 4` と打つと、`12` が返ってくるような関数を組み立てることはできるだろうか？
  - ヒント：Haskellにおいて関数はふつうの値の一種だから、関数の結果として返してもよい

### 関数・型シグネチャ・パターンマッチ
- 節末問題の答えはこんなふうである：
```haskell
-- ↓これが複数行コメント
{-
kakezan をこんなふうに定義すると、 kakezan 3 は \y -> 3 * y という関数になる
そうしたら、(kakezan 3) 4 は 3 * 4 = 12 になる
-}
kakezan = \x -> (\y -> x * y)
```
- ところで、いちいち `(kakezan 3) 4` とするのも、 `\x -> (\y -> x * y)` と打つのもまどろっこしいから、次のように書けるようになっている
```haskell
-- これらはいずれも上の kakezan と同じ意味である
kakezan2 = \x y -> x * y 
kakezan3 x y = x * y 

-- 関数適用は左結合で、優先度は最大である
_3x4 = kakezan 3 4
```
- Haskellにおいて「多変数関数」のように見えるものは、「引数を一個取って、のこりの引数を受け取る関数を返す関数」である

- また、関数の引数として関数を渡してもかまわない
```haskell
-- 二引数関数・整数・整数を受け取って、計算して返す
keisan f x y = f x y

-- 中置演算子は丸括弧で囲むとふつうの関数のように扱える
_4x5 = (*) 4 5

tashizan = keisan (+)
hikizan  = keisan (-)

_9plus8 = tashizan 9 8 -- 17
```











# スタブ

### 処理系との約束事
- みなさんも、他の言語で「mainから実行される」みたいな約束事を見たことがあるとおもう
1. プログラム中のすべての式は、それを評価した値に書き換えても（計算時間をのぞいて）プログラムの振る舞いを変えない
   - 端的にいえば、「関数はすべて純粋です」ということ
   - 例えば、`someFunc 6` が `36` になるならば、プログラム中のすべての `someFunc 6` を `36` に置き換えてもプログラムの振る舞いは変わらない
   - コンパイラにとってこの約束は「返り値さえ同じなら、めっちゃアグレッシブに最適化をしてもかまわない」ということ
2. この約束はややこしいので、しばらく忘れていてほしい→ ~~プログラムが実行される際には、`main`という名で型が`IO ()`の手続きが走る~~
   - javascript風に説明するならば、プログラマは`main`という名のクソデカPromiseを組み立てて、実行時にはそれが走るということ