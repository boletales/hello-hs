# Haskell入門

## 第0章 はじめに
### モチベーション
- このドキュメントでは、Haskellの環境構築と基本的な文法から始めて、最終的にパーサコンビネータまで扱いたいと考えている
  
- みなさんは以下のようなスタイルのプログラミングをしたことがあるだろうか：
  - 入力や表示を行う部分と、ただ計算をするだけの部分を分離する
  - グローバル変数の使用を避ける
  - 引数だけに依存し、副作用を起こさず値を返す小さな関数ををたくさんつくる
  - 関数の引数としてラムダ式を渡したり、返り値としてラムダ式を返したりする
- ↑の1つ目と2つ目はプログラミング慣れした人々にとって一般的な慣習だと思う
- これに3つ目と4つ目を加えたのが、いわゆる「関数型プログラミング」というスタイルである
  
- あるいは、みなさんは次のような感覚や行動に心当たりがないだろうか：
  - 関数を書くとき、副作用が起こらないように「気をつけた」ことがある
  - 配列に対するforEachでは躊躇なく副作用を起こすが、mapの中で副作用を起こすのは筋が悪いように感じる
  - 式に型が付いていると安心するが、どこにでも型を書かされるのは煩わしいと思う
  - 開発者コンソールやREPLでワンライナーを書くのが好きである
  - メソッドチェーンを使うのは楽しいと思う

- プログラミングの文脈において、「関数」という言葉には次の二側面が含まれている：
  - 関数とは、「手続きの流れを切り出したもの」である。値を受け取ったり値を返したりすることもある
  - 関数とは、「値を受け取って、値を返すなにか」である。（Haskellにおいてはそうでないが、）その途中でなにか他のことをするかもしれない
- 多くの「ふつうのプログラミング言語」では、前者の意味での「関数」が言語機能として用意されている
  - 特に関数型っぽい書き方をする際には、前者を後者で模倣するために、前者を後者だとがんばって思い込むことを強いられる
- いわゆる「関数型プログラミング言語」と呼ばれる種類の言語では、「関数」はおおかた後者の意味のように振る舞う

- Haskellは、快適に関数型プログラミングをするためのプログラミング言語である
  - 関数が「値を受け取って値を返し、他にはないにもしないもの」としてふるまうことを言語仕様で実現している
- 具体的な特徴：
  - 関数は「ふつうの値」なので、引数として渡したり、返り値として返したりしてよい
  - すべての関数は純粋であり、いかなる場合でも関数適用はその値に置き換えても構わない（と約束する）
    - つまり、他の言語のように書くならば、`hoge(42) == true` ならばプログラム中の `hoge(42)` を全部 `true` に置換して構わないということである
    - コンパイラにとっては「返り値が変わらないならどんなアグレッシブな最適化も許容される」ことを意味する
  - すべての式には型が付いており、コンパイル時に検査される
    - ただし、型推論が強いので、型注釈をほとんど書かなくても正しく動く
  - コンパイラによる強烈な最適化が効きさえすれば、同じ実装課題についておおむねJavaと等速で（C比3倍程度）動作する
    - 「他の手続き型プログラミング言語で同じように関数型の書き方をしたコード」と比較すると異様に速い
  - 他の言語で副作用と呼ばれるものは、HaskellではIOアクションと呼ばれる種類の純粋な値である（この話はややこしいのでしばらく忘れていてほしい）
    - IOアクションは、javascriptで例えれば「勝手に発火せず入れ子にできる行儀のよいPromise」のようなものである
    - Haskellにおいて、プログラマのやることはエントリポイントとなるクソデカPromiseを組み立てることである

- 最後に具体的なコード例を示すことにする。ここで出てくるさまざまな要素はのちほどで説明する：
```haskell
main :: IO ()
main = putStrLn =<< (tanuki <$> getLine)

-- 文字列から「た」を抜く関数
tanuki :: String -> String
tanuki = filter (\c -> c /= 'た')

-- ↓HLSを導入しているエディタ上では、こういうコメントを書くと式の評価結果を確認できる
-- >>> tanuki "こたんたたにたちたは"
-- "こんにちは"
```
- しょっぱなから`->`だとか`<$>`だとか、あげくの果てに`=<<`だとかいう記号を見せられて面食らってるだろうが、あとで全部説明するから信じてほしい


### 環境構築
- ツールチェーンマネージャの [GHCup](https://www.haskell.org/ghcup/) を使うと手っ取り早い（2024年時点で推奨のインストール方法）
  - 参考：（これらのコマンドは公式のページからコピペしたほうが確実だと思う）
  - Windowsの場合、PowerShell上で `Set-ExecutionPolicy Bypass -Scope Process -Force;[System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; try { Invoke-Command -ScriptBlock ([ScriptBlock]::Create((Invoke-WebRequest https://www.haskell.org/ghcup/sh/bootstrap-haskell.ps1 -UseBasicParsing))) -ArgumentList $true } catch { Write-Error $_ }`
  - Linuxの場合、 `{curl --proto '=https' --tlsv1.2 -sSf https://get-ghcup.haskell.org | sh}`
- 途中「stackを入れるか」「hlsを入れるか」と訊かれるが、それぞれyを選んでほしい
- その他の質問にはデフォルトの回答をしておけばよかったはず
- インストールされるもの
  - GHCup（Haskellのツールチェーンを管理するやつ）
  - GHC（コンパイラ）
  - cabal（パッケージマネージャ）
  - stack（cabalのラッパー）
  - hls（エディタの補完をしてくれるやつ）
- Windowsの場合は、ここまで終わったら一度再起動することを推奨する

- VSCodeに拡張機能 haskell.haskell をインストールする
- ここまでで、Haskellの環境構築は完了した（便利な時代になりました）

## 第1章 関数やリストとたわむれる
### ghci（デバッグに便利な対話環境）の使い方
- ターミナルで `ghci` というコマンドを打つと対話環境が起動する
- `100 + 200` とか、`2 ** 10` とか、適当に数式を打ってみよう！評価してくれるぞ！
- `someconst = 3` みたいに定数を定義すると、あとで使うことができる
- 関数はふつうの値なので、`nibai = \x -> x * 2` みたいに打てば定義できる
  - ここで、`\x -> x * 2` は「引数xを受け取ってx * 2を返す関数」という意味
  - 関数を定義したかったら `sanbai x = x * 3` のように書くこともできる
- 関数を使うには、関数のあとにスペースを空けて引数を書けばいい
  - `nibai 3` と打つと、`6`が帰ってくる
- ghciは`:q` で終了できる

- どこか適当なフォルダに、`hoge.hs` というファイルを作って、以下のように書いてみる
  - （この先しばらく、VSCodeで`hoge.hs`とターミナルを開きながら作業する）
```haskell
-- ↓コメント
-- Haskellのプログラムは基本的に、定数の宣言でできている
someconst = 3

nibai = \x -> x * 2

sanbai x = x * 3
```
- ghciを起動して、`:l hoge.hs` と打つと、`hoge.hs` の宣言が読み込まれる
- 当然 `someconst` と打てば `3` が返ってくるし、`nibai someconst` と打てば `6` が返ってくる

#### 節末問題
- ここまでの知識だけで、「二個の引数を取る関数」は作れるだろうか？
  - たとえば、`(kakezan 3) 4` と打つと、`12` が返ってくるような関数を組み立てることはできるだろうか？
  - ヒント：Haskellにおいて関数はふつうの値の一種だから、関数の結果として返してもよい

### 関数・型シグネチャ
- 節末問題の答えはこんなふうである：
```haskell
-- ↓これが複数行コメント
{-
kakezan をこんなふうに定義すると、 kakezan 3 は \y -> 3 * y という関数になる
そうしたら、(kakezan 3) 4 は 3 * 4 = 12 になる
-}
kakezan = \x -> (\y -> x * y)
```
- ところで、いちいち `(kakezan 3) 4` とするのも、 `\x -> (\y -> x * y)` と打つのもまどろっこしいから、次のように書けるようになっている
```haskell
-- これらはいずれも上の kakezan と同じ意味である
kakezan2 = \x y -> x * y 
kakezan3 x y = x * y 

-- 関数適用は左結合で、優先度は最大である
_3x4 = kakezan 3 4
```
- Haskellにおいて「多変数関数」のように見えるものは、「引数を一個取って、のこりの引数を受け取る関数を返す関数」である

- また、関数の引数として関数を渡してもかまわない
```haskell
-- 二引数関数・整数・整数を受け取って、計算して返す
keisan f x y = f x y

-- 中置演算子は丸括弧で囲むとふつうの関数のように扱える
_4x5 = (*) 4 5

tashizan = keisan (+)
hikizan  = keisan (-)

_9plus8 = tashizan 9 8 -- 17
```






